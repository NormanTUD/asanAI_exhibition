<?php
    $GLOBALS['translations'] = array(
	    'en' => array(

		    "predicted_category" => "Predicted category",
		    "correct_category" => "Correct category",
		    "model_was_set" => "Model was set properly",
		    "example_csv_shoe_size" => "Load example shoe data (0 = male, 1 = female)",
		    "we_want_to_train_this_model_5_categories" => "The computer should now learn to classify the images into one of the five categories.",
		    "fire" => "Fire prevention",
		    "mandatory" => "Mandatory",
		    "prohibition" => "Prohibition",
		    "rescue" => "Rescue",
		    "warning" => "Warning",
		    "the_more_variations_the_model_sees" => "The more variations the model sees, the better it can learn important features of the images.",
		    "quality_depends_on_random" => "The quality of the results depends on randomness.",
		    "program_looks_at_data" => "The learning process (training) is now running and the computer tries, through trial and error, many different filter configurations.",
		    "the_further_on_top_the_better" => "Especially at the beginning of the training, many images are initially classified into the wrong category. As the training progresses, the correct category is increasingly assigned, and this assignment becomes more reliable. The categorical assignment is more reliable the higher an image moves up into the blue area.",
		    "add_category" => "Add category",
		    "settings" => "Settings",
		    "description" => "Description",
		    "use_bias" => "Use Bias",
		    "activation_function" => "Activation function",
		    "bias_initializer" => "Bias-Initializer",
		    "kernel_initializer" => "Kernel-Initializer",
		    "trainable" => "Trainable",
		    "visualize_layer" => "Visualize layer",
		    "visualize_this_layer" => "Visualize this layer",
		    "examples" => "Examples",
		    "dataset" => "Dataset",
		    "height" => "height",
		    "width" => "width",
		    "batch_size" => "Batch-Size",
		    "epochs" => "Epochs",
		    "own_data" => "Data Source",
		    "filters" => "Filters",
		    "distribution" => "Distribution",
		    "image_options" => "Image Options",
		    "feature_extraction" => "Feature ex&shy;traction",
		    "classification" => "Classi&shy;fication",
		    "flatten" => "Flatten",
		    "dataset_and_network" => "Dataset and network",
		    "visualization" => "Model Visualization",
		    "data" => "Data",
		    "training_data" => "Data",
		    "currently_the_network_has_seen" => "The remaining time of this training will be",
		    "of" => "of",
		    "times_seen" => "times.",
		    "it_will_take_about" => "It will take about",
		    "remain_left" => " ",
		    "camera_draw_self" => "Camera\/draw",
		    "click_on" => "Touch",
		    "if_bad_continue_training" => "If the results are still bad, continue training.",
		    "the_ai_thinks_categories_look_like_this" => "A visual representation of what the AI has learnt",
		    "it_might_only_be_noise" => "Thats why you are probably only seeing random noise and the detection may not work properly yet.",
		    "image_left" => "image left",
		    "images_left" => "images left",
		    "beginner" => "Beginner",
		    "expert" => "Expert",
		    "except_last_layer" => "except last layer",
		    "activation_functions" => "Activation functions",
		    "set_for_all_layers" => "Set for all layers",
		    "shuffle_before_each_epoch" => "Shuffle before each epoch",
		    "summary" => "Summary",
		    "own_images" => "Own images",
		    "own_tensor" => "Own tensors",
		    "kernel_size" => "Kernel-Size",
		    "start_training" => "Start training",
		    "stop_training" => "Stop training",
		    "imprint" => "Imprint",
		    "change_shape" => "Change shape",
		    "simulate_real_data" => "Simulate real data",
		    "dimensionality_reduction" => "Di&shy;men&shy;sio&shy;na&shy;lity re&shy;duc&shy;tion",
		    "shy_activation_function" => "Ac&shy;ti&shy;va&shy;tion fun&shy;ction",
		    "shy_overfitting_prevention" => "Pre&shy;vent Over&shy;fit&shy;ting",
		    "rescale_and_recenter" => "Re-scale and re-center data",
		    "show_layer_data_flow" => "Show layer data flow",
		    "show_grad_cam" => "Show gradCAM",
		    "code" => "Code",
		    "own_csv" => "Own CSV",
		    "training" => "Training",
		    "predict" => "Predict",
		    "hyperparameters" => "Hyperparameters",
		    "valsplit" => "Val.-Split",
		    "divide_x_by" => "Divide <i>X<\/i> by",
		    "metric" => "Metric",
		    "loss" => "Loss",
		    "optimizer" => "Optimizer",
		    "learning_rate" => "Learning Rate",
		    "enable_tf_debug" => "Enable TFJS Debugger",
		    "enable_webcam" => "Enable webcam",
		    "disable_webcam" => "Disable webcam",
		    "switch_to_other_cam" => "Switch to other cam",
		    "copy_to_clipboard" => "Copy to clipboard",
		    "copy_to_clipboard_debug" => "Copy to clipboard (debug)",
		    "set_all_initializers" => "Set all Initializers",
		    "augmentation" => "Augmentation",
		    "iterations" => "Iterations",
		    "close" => "Close",
		    "register" => "Register",
		    "csv" => "CSV",
		    "math" => "Math",
		    "smaller" => "Smaller",
		    "larger" => "Larger",
		    "reset" => "Reset",
		    "delete_predictions" => "Delete predictions",
		    "memory_usage_while_training" => "Memory usage while training (per batch)",
		    "img_per_cat" => "Img\/cat",
		    "batches" => "Batches",
		    "login" => "Login",
		    "username" => "Username",
		    "password" => "Password",
		    "download" => "Download",
		    "email" => "E-Mail",
		    "public" => "Public",
		    "save" => "Save",
		    "augment" => "Augment",
		    "download_model_data" => "Download model data",
		    "logout" => "Logout",
		    "load" => "Load",
		    "download_for_local_taurus" => "Download for local\/taurus training",
		    "max_activated_neurons" => "Max. activated neurons",
		    "no_default_data" => "Default data",
		    "yes_own_tensor" => "&#x2318; Own tensor-data",
		    "yes_own_csv" => "&#128290; Own CSV",
		    "yes_own_images" => "&#128444; Own images\/webcam",
		    "width_amp_height" => "Width&amp;height (0 = auto)",
		    "randomizer_limits" => "Randomizer Limits",
		    "max_neurons_fcnn" => "Max. neurons FCNN",
		    "various_plots" => "Various Plots",
		    "sources_and_used_programs" => "Sources and used programs",
		    "visualize_images_in_grid" => "Visualize images in grid",
		    "model_compiled_successfully" => "Model compiled successfully",
		    "not_creating_model_because_values_are_missing" => "Not creating model because some values are missing",
		    "tensors" => "Tensors",
		    "set_val_split_to" => "Set validationSplit to ",
		    "set_optimizer_to" => "Setting optimizer to ",
		    "set_metric_to" => "Setting metric to ",
		    "set_loss_to" => "Setting loss to ",
		    "show_bars_instead_of_numbers" => "Show bars instead of numbers",
		    "number_of_grid_images" => "Number of grid images",
		    "show_raw_data" => "Show raw data",
		    "pixel_size" => "Pixel size",
		    "auto_rotate_images" => "Auto rotate images",
		    "number_of_rotations" => "Number of rotations",
		    "pretext_prepare_data" => "You must prepare your dataset yourself! You can use this piece of code to generate the data file in the correct format after you pre-processed them.",
		    "reset_view" => "Reset view",
		    "reinitialize_weights" => "Reinitialize weights",
		    "show_input_layer" => "Show Input-Layer",
		    "batch_plot_minimum_time" => "Batch-Plot-Minimum-Time",
		    "loss_metric_data_and_shape" => "Loss, Metric, Data and Shapes",
		    "sine_ripple" => "Sine-Ripple",
		    "invert_images" => "Invert images",
		    "flip_left_right" => "Flip left and right",
		    "layer_data_flow" => "Layer data flow",
		    "dense_description" => "Creates a dense (fully connected) layer.<br>This layer implements the operation => <span class=\"temml_me\">\\mathrm{output} = \\mathrm{activation}\\left(\\mathrm{input} \\cdot \\mathrm{kernel} + \\text{bias}\\right)<\/span>. Activation is the element-wise activation function passed as the activation argument.<br><tt>kernel<\/tt> is a weights matrix created by the layer.<br><tt>bias<\/tt> is a bias vector created by the layer (only applicable if useBias is true).",
		    "flatten_description" => "Flattens the input. Does not affect the batch size. A Flatten layer flattens each batch in its inputs to 1D (making the output 2D).",
		    "dropout_description" => "Dropout consists in randomly setting a fraction rate of input units to 0 at each update during training time, which helps prevent overfitting.",
		    "reshape_description" => "Reshapes an input to a certain shape.",
		    "elu_description" => "Exponential Linear Unit (ELU).<br>Equation => <span class='temml_me'>\\text{elu}\\left(x\\right) = \\left\\{\\begin{array}{ll} \\alpha \\cdot \\left(e^x - 1\\right) & \\text{for } x < 0 \\\\ \n x & \\text{for } x >= 0\\end{array}\\right.<\/span>",
		    "leakyReLU_description" => "Leaky version of a rectified linear unit.<br>It allows a small gradient when the unit is not active => <span class='temml_me'>\\text{leakyReLU}(x) = \\left\\{\\begin{array}{ll} \\alpha \\cdot x & \\text{for } x < 0 \\\\ \n x & \\text{for } x >= 0 \\end{array}\\right.<\/span>",
		    "reLU_description" => "Rectified Linear Unit activation function. <span class=\"temml_me\">\\mathrm{relu}\\left(x\\right) = \\mathrm{max}\\left(\\mathrm{Max-Value}, x\\right)<\/span>",
		    "softmax_description" => "Softmax activation layer. <span class=\"temml_me\">\\mathrm{softmax}\\left(x\\right) = \\frac{e^{z_j}}{\\sum^K_{k=1} e^{z_k}}<\/span>",
		    "thresholdedReLU_description" => "Thresholded Rectified Linear Unit. Equation => <span class='temml_me'>f(x) = \\left\\{\\begin{array}{ll} x & \\text{for } x > \\theta \\\\ \n 0 & \\text{otherwise}\\end{array}\\right.<\/span>",
		    "batchNormalization_description" => "Batch normalization layer (<a href='https =>\/\/arxiv.org\/abs\/1502.03167' target='_blank'>Ioffe and Szegedy, 2014<\/a>).<br>Normalize the activations of the previous layer at each batch, i.e. applies a transformation that maintains the mean activation close to 0 and the activation standard deviation close to 1.",
		    "layerNormalization_description" => "Layer-normalization layer (<a target='_blank' href='https =>\/\/arxiv.org\/abs\/1607.06450'>Ba et al., 2016<\/a>). Normalizes the activations of the previous layer for each given example in a batch independently, instead of across a batch like in batchNormalization. In other words, this layer applies a transformation that maintanis the mean activation within each example close to 0 and activation variance close to 1.",
		    "conv1d_description" => "1D convolution layer (e.g., temporal convolution).<br>This layer creates a convolution kernel that is convolved with the layer input over a single spatial (or temporal) dimension to produce a tensor of outputs.<br>If <tt>use_bias<\/tt> is True, a bias vector is created and added to the outputs.<br>If <tt>activation<\/tt> is not <tt>null<\/tt>, it is applied to the outputs as well.",
		    "conv2d_description" => "2D convolution layer (e.g. spatial convolution over images).<br>This layer creates a convolution kernel that is convolved with the layer input to produce a tensor of outputs.<br>If <tt>useBias<\/tt> is True, a bias vector is created and added to the outputs.<br>If <tt>activation<\/tt> is not null, it is applied to the outputs as well.",
		    "conv2dTranspose_description" => "Transposed convolutional layer (sometimes called Deconvolution). The need for transposed convolutions generally arises from the desire to use a transformation going in the opposite direction of a normal convolution, i.e., from something that has the shape of the output of some convolution to something that has the shape of its input while maintaining a connectivity pattern that is compatible with said convolution.",
		    "conv3d_description" => "3D convolution layer (e.g. spatial convolution over volumes).<br>This layer creates a convolution kernel that is convolved with the layer input to produce a tensor of outputs.",
		    "depthwiseConv2d_description" => "Depthwise separable 2D convolution. Depthwise Separable convolutions consists in performing just the first step in a depthwise spatial convolution (which acts on each input channel separately). The depthMultiplier argument controls how many output channels are generated per input channel in the depthwise step.",
		    "separableConv2d_description" => "Depthwise separable 2D convolution. Separable convolution consists of first performing a depthwise spatial convolution (which acts on each input channel separately) followed by a pointwise convolution which mixes together the resulting output channels. The depthMultiplier argument controls how many output channels are generated per input channel in the depthwise step.",
		    "upSampling2d_description" => "Upsampling layer for 2D inputs. Repeats the rows and columns of the data by <tt>size[0]<\/tt> and <tt>size[1]<\/tt> respectively.",
		    "averagePooling1d_description" => "Average pooling operation for spatial data.",
		    "averagePooling2d_description" => "Average pooling operation for spatial data.",
		    "averagePooling3d_description" => "Average pooling operation for 3d data.",
		    "maxPooling1d_description" => "Max pooling operation for temporal data.",
		    "maxPooling2d_description" => "Global max pooling operation for spatial data.",
		    "maxPooling3d_description" => "Global max pooling operation for 3d data.",
		    "alphaDropout_description" => "Applies Alpha Dropout to the input. As it is a regularization layer, it is only active at training time.",
		    "gaussianDropout_description" => "Apply multiplicative 1-centered Gaussian noise. As it is a regularization layer, it is only active at training time.",
		    "gaussianNoise_description" => "Apply additive zero-centered Gaussian noise. As it is a regularization layer, it is only active at training time.",
		    "DebugLayer_description" => "Log internal state of the data to the developer's console (like <tt>console.log<\/tt>). Does nothing to the data itself and returns them unchanged.",
		    "max_number_of_values" => "Max number of values (0 = no limit)",
		    "provide_x_data" => "Provide X-data file",
		    "provide_y_data" => "Provide Y-data file",
		    "download_custom_zip_file" => "Download custom data in a .zip file",
		    "delay_between_images" => "Delay in seconds between images in a series",
		    "number_of_images_in_series" => "Number of images in a series",
		    "restart_fcnn" => "Restart FCNN",
		    "restart_lenet" => "Restart LeNet",
		    "undo_redo_stack_lost" => "Undo\/redo stack lost!",
		    "changing_mode_deletes_stack" => "Changing the mode deletes the undo\/redo stack.",
		    "auto_adjust_last_layer_if_dense" => "Auto-adjust last layer's number of neurons (if Dense)",
		    "load_images" => "Load Images",
		    "loading_data" => "Loading data",
		    "ai_tries_to_draw" => "The AI tries to draw how it thinks the categories look like...",
		    "stop_generating_images" => "Stop generating images",
		    "stopped_generating_images" => "Stopped generating new images, this may take a while",
		    "now_being" => "Now, ",
		    "images_of_each_category" => "Images of each categories are being loaded.",
		    "one_second" => "1 second",
		    "years" => "years",
		    "year" => "year",
		    "minutes" => "minutes",
		    "minute" => "minute",
		    "seconds" => "seconds",
		    "hours" => "hours",
		    "second" => "second",
		    "days" => "days",
		    "day" => "day",
		    "left" => "left",
		    "example_images" => "Example Images",
		    "and_try_to_draw_a_warning_sign" => "and try to draw a warning sign",
		    "go_back_to_examples" => "to go back to example images",
		    "the_training_was_only_with" => "The training has been done with only",
		    "images_and" => "images and",
		    "epochs_done" => "epochs done. Thus, the results are probably bad",
		    "this_may_take_a_while" => "This may take a while",
		    "loading_images_into_memory" => "Loading images into memory",
		    "train_the_neural_network" => "Tap here to train neural network",
		    "train_further" => "Train the network further",
		    "loading_model" => "Loading model",
		    "loading_example_images" => "Loading example images",
		    "undoing_redoing" => "Undoing\/redoing",
		    "skip_presentation" => "Skip &rarr;",
		    "very_unsure" => "Very unsure",
		    "quite_unsure" => "Quite unsure",
		    "a_bit_unsure" => "A bit unsure",
		    "neutral" => "A bit sure",
		    "relatively_sure" => "Relatively sure",
		    "very_sure" => "Very sure",
		    "time_per_batch" => "Time per Batch",
		    "done_training_took" => "Done Training, took",
		    "done_generating_images" => "Done generating images",
		    "generating_image_for_neuron" => "Generating image for neuron",
		    "failed_try_again" => "failed. Trying again",
		    "fixing_output_shape" => "Output shape is being fixed...",
		    "output_shape_repaired" => "Output shape repaired",
		    "please_try_training_again" => "Please try training again",
		    "No" => "No",
		    "Yes" => "Yes",
		    "autofix_output_shape" => "Do you want to automatically fix the output shape?",
		    "defective_output_shape" => "Defective output shape detected",
		    "switched_to_beginner_mode" => "Switched to beginner mode",
		    "changed_mode_from" => "Changed mode from",
		    "to" => "to",
		    "lost_undo_redo_stack" => "lost undo\/redo stack",
		    "stopped_training" => "Stopped training",
		    "allow_math_mode_for_all_layers" => "Allow math mode for all layers",
		    "updating_predictions" => "Updating predictions",
		    "loaded_configuration" => "Loaded configuration",
		    "model_is_not_defined" => "Model is not defined",
		    "model_is_ok" => "Model is OK",
		    "got_data" => "Got data, tensors created",
		    "site_is_ready" => "Site is ready",
		    "trying_to_set_backend" => "Trying to set backend",
		    "backend_set" => "Backend set",
		    "set_theme" => "Set theme",
		    "theme_set" => "Theme set",
		    "has_cookie_for" => "Has cookie for",
		    "initializing_losses" => "Initializing losses",
		    "initializing_metrics" => "Initializing metrics",
		    "setting_backend" => "Setting backend",
		    "changing" => "Changing",
		    "changed_data_source" => "Changed data source",
		    "hiding_augmentation" => "Hiding augmentation",
		    "showing_augmentation" => "Showing augmentation",
		    "input_shape_is_read_only" => "The Input-Shape read-only",
		    "input_shape_is_writable" => "The Input-Shape is editable",
		    "updating_page" => "Updating page...",
		    "page_update_took" => "Page update took",
		    "getting_labels" => "Getting labels",
		    "compiling_model" => "Compiling model",
		    "done_changing" => "Done changing",
		    "took" => "took",
		    "setting_layer" => "Setting layer",
		    "setting_options_for_layer" => "Setting options for layer",
		    "creating_model" => "Creating model",
		    "graph_explanation" => "The lines in the graph represent the error. The lower the line, the smaller the error.<hr class='cosmo_hr'>The blue line indicates the improvements on the data that the network is trained on, while the orange line indicates how well it performs on data it hasn't seen before.<hr class='cosmo_hr'>Both lines should decrease and look somewhat similar for the training to be progressing well.",
		    "previous_images" => "Previous images",
		    "current_images" => "Current images",
		    "predictions_explanation_while_training" => "Down below is one example of each category. The bars show the calculated likelyhood of the image to be in that category. The most strongly detected category is green. You can see the Categories change as the network learns.",
		    "Brandschutz" => "Fire prevention",
		    "Verbot" => "Prohibition",
		    "Gebot" => "Mandatory",
		    "Rettung" => "Rescue",
		    "Warnung" => "Warning",
		    "currently" => "Currently",
		    "correct" => "correct",
		    "wrong" => "Wrong",
		    "total" => "Total",
		    "images_are_being_detected_correctly" => "images are being detected correctly",
		    "category" => "Kategorie",
		    "percentage_correct" => "Percentage correct",
		    "training_done_text" => "The training phase is complete. If the accuracy is still insufficient, the network can be further trained to potentially achieve better results.",
		    "initializing_categories" => "Initializing categories",
		    "initializing_tabs" => "Initialisiere Tabs",
		    "initializing_page_contents" => "Initializing page contents",
		    "initializing_set_options_for_all" => "Initializing 'set options for all'",
		    "got_data_creating_tensors" => "Got data, creating tensors...",
		    "started_training" => "Started training",
		    "compiling model" => "Compiling model",
		    "compiled_model" => "Compiled model",
		    "finished_training" => "Finished training",
		    "stopped_downloading_because_button_was_clicked" => "Stop downloading because stop-download-button was clicked",






		    "model_was_set" => "Model was set properly",
		    "correct_category" => "Correct category",
		    'optimizer' => 'Optimizer',
		    'a_neural_network_is_an_algorithm_that_mimics_the_functionality_of_the_human_brain' => 'A Neural Network is an algorithm that mimics the functionality of the human brain.',
		    'it_can_solve_complex_tasks_in_computer_science_economics_mathematics_etc' => 'It can solve complex tasks in computer science, economics, mathematics, etc.',
		    'a_neural_network_is_trained' => 'A Neural Network is trained.',
		    'this_model_of_machine_learning_is_also_the_basis_for_artificial_intelligences' => 'This model of Machine Learning is also the basis for Artificial Intelligences.',

		    'like_the_human_brain_a_neural_network_also_consists_of_artificial_neurons' => 'Like the human brain, a neural network also consists of (artificial) neurons.',
		    'the_neurons_are_arranged_in_different_layers_the_input_layer_receives_the_initial_data_such_as_images' => 'The neurons are arranged in different layers. The input layer receives the initial data, such as images.',
		    'afterwards_several_hidden_layers_follow_where_the_edges_between_the_nodes_are_weighted' => 'Afterwards, several hidden layers follow where the edges between the nodes are weighted.',
		    'the_output_layer_provides_the_image_category_calculated_based_on_the_input_data' => 'The output layer provides the image category calculated based on the input data.',

		    'the_neurons_receive_modify_and_pass_on_information_to_the_next_neuron' => 'The neurons receive, modify, and pass on information to the next neuron.',
		    'the_variously_weighted_edges_leading_to_a_neuron_determine_the_value_of_the_next_neuron' => 'The variously weighted edges leading to a neuron determine the value of the next neuron.',
		    'an_activation_function_decides_whether_and_with_what_value_information_is_passed_on_to_the_next_neuron' => 'An activation function decides whether and with what value information is passed on to the next neuron.',

		    'the_network_is_trained_on_a_classified_dataset' => 'The network is trained on a classified dataset.',
		    'it_learns_through_feedback_whether_the_predicted_output_is_right_or_wrong' => 'It learns through feedback whether the predicted output is right or wrong.',
		    'the_values_in_the_input_layer_are_randomly_chosen_at_first_and_adjusted_with_each_pass_through_the_neural_network_until_the_correct_result_is_output_in_the_output_layer' => 'The values in the input layer are randomly chosen at first and adjusted with each pass through the neural network until the correct result is output in the output layer.',
		    'learning_rate' => 'Learning Rate',
		    'try_it' => "Try it",
		    "neural_network" => "Neural Network",

		    'choose_an_existing_dataset_or_create_your_own' => 'Choose an existing dataset or create your own',
		    'fruit' => 'Fruit',
		    'everyday_objects' => 'Everyday objects',
		    'own_dataset' => 'Own dataset',

		    'load_test_images_and_start_training' => 'Load test images and start training',
		    'categorized_test_images_are_loaded_for_each_fruit' => 'Categorized test images are loaded for each fruit.',
		    'the_neural_network_selects_a_random_path_through_the_network_for_each_image' => 'The neural network selects a random path through the network for each image.',
		    'if_a_wrong_result_occurs_it_is_corrected' => 'If a wrong result occurs, it is corrected.',
		    'using_this_feedback_the_path_is_adjusted_until_the_network_arrives_at_the_correct_output' => 'Using this feedback, the path is adjusted until the network arrives at the correct output.',
		    'the_more_passes_the_more_effective_the_training' => 'The more passes, the more effective the training.',
		    'in_this_example_there_are' => 'In this example, there are',
		    'passes' => 'passes',
		    'hold_a_fruit_in_front_of_the_camera' => 'Hold a fruit in front of the camera:',
		    'hold_a_key_coin_or_bill_into_the_camera' => 'Hold a coin, key or bill in front the of the camera:',
		    'the_input_image_is_converted_into_a_matrix_with' => 'The input image is converted into a matrix with',
		    'pixels_representing_the_height_and_width_with_color_channels_red_green_and_blue' => 'pixels, representing the height and width with color channels red, green, and blue.',
		    "hold_one_of_the_objects_you_trained_the_network_on_in_front_of_the_camera" => "Hold one of the objects that you trained the network on in front of the camera:",
		    'in_the_layers_various_features_such_as_edges_are_filtered_from_the_image' => 'In the layers, various features such as edges are filtered from the image.',
		    'in_each_layer_the_image_is_sampled_section_by_section_using_kernels' => 'In each layer, the image is sampled section by section using kernels.',
		    'based_on_the_extracted_features_the_image_is_finally_classified' => 'Based on the extracted features, the image is finally classified.',

		    'show_evaluation' => 'Show evaluation',
		    'try_yourself' => 'Try yourself',
		    'the_input_image_is_converted_into_a_matrix_with' => 'The input image is converted into a matrix with',
		    'pixels_representing_height_and_width_and_color_channels_red_green_blue' => 'pixels, representing height and width and color channels red, green, and blue.',
		    'various_features_such_as_edges_are_filtered_from_the_image_in_the_layers' => 'Various features, such as edges, are filtered from the image in the layers.',
		    'in_each_layer_the_image_is_sampled_section_by_section_using_kernels' => 'In each layer, the image is sampled section by section using kernels.',
		    'based_on_extracted_features_the_image_is_classified' => 'Based on extracted features, the image is classified.',

		    'load_test_images_and_start_training' => 'Load test images and start training',
		    'for_each_category_categorized_test_images_are_loaded' => 'For each category, categorized test images are loaded.',
		    'the_neural_network_selects_a_random_path_through_the_network_for_each_image' => 'The neural network selects a random path through the network for each image.',
		    'if_a_wrong_result_occurs_it_is_corrected' => 'If a wrong result occurs, it is corrected.',
		    'with_the_help_of_this_feedback_the_path_is_adjusted_until_the_network_reaches_a_correct_output' => 'With the help of this feedback, the path is adjusted until the network reaches a correct output.',
		    'the_more_iterations_there_are_the_more_effective_the_training' => 'The more iterations there are, the more effective the training.',
		    'in_this_example_there_are' => 'In this example, there are',
		    'iterations' => 'iterations.',
		    'show_evaluation' => 'Show evaluation',
		    'try_yourself' => 'Try yourself',
		    'hold_a_key_a_banknote_or_a_coin_in_front_of_the_camera' => 'Hold a key, a banknote, or a coin in front of the camera:',
		    'the_input_image_is_converted_into_a_matrix_with' => 'The input image is converted into a matrix with',
		    'pixels_representing_height_and_width_and_color_channels_red_green_blue' => 'pixels, representing height and width and color channels red, green, and blue.',
		    'various_features_such_as_edges_are_filtered_from_the_image_in_the_layers' => 'Various features, such as edges, are filtered from the image in the layers.',
		    'in_each_layer_the_image_is_sampled_section_by_section_using_kernels' => 'In each layer, the image is sampled section by section using kernels.',
		    'based_on_extracted_features_the_image_is_classified' => 'Based on extracted features, the image is classified.',

		    'for_images_of_each_category_test_images_are_loaded' => 'For images of each category, test images are loaded.',
		    'the_neural_network_selects_a_random_path_through_the_network_for_each_image' => 'The neural network selects a random path through the network for each image.',
		    'if_a_wrong_result_occurs_it_is_corrected' => 'If a wrong result occurs, it is corrected.',
		    'with_the_help_of_this_feedback_the_path_is_adjusted_until_the_network_reaches_a_correct_output' => 'With the help of this feedback, the path is adjusted until the network reaches a correct output.',
		    'the_more_iterations_there_are_the_more_effective_the_training' => 'The more iterations there are, the more effective the training.',
		    'in_this_example_there_are' => 'In this example, there are',
		    'iterations' => 'iterations.',

		    'hold_one_of_the_trained_objects' => 'Hold one of the objects, on which the model was trained, in front of the camera:',
		    'the_input_image_is_converted_into_a' => 'The input image is converted into a',
		    'pixel_matrix_representing_height_width_and_rgb_channels' => '-pixel matrix, representing the height, width, and the RGB color channels.',
		    'in_the_layers_various_features_such_as_edges_are_filtered_from_the_image' => 'In the layers, various features such as edges are filtered from the image.',
		    'in_each_layer_the_image_is_scanned_by_kernels_section_by_section' => 'In each layer, the image is scanned by kernels, section by section.',
		    'based_on_the_extracted_features_the_image_is_eventually_classified' => 'Based on the extracted features, the image is eventually classified.',

		    'show_results' => 'Show Results',
		    'try_it_yourself' => 'Try it Yourself',

		    'add_category' => 'Add Category',
		    'start_training' => 'Start Training',

		    "images_required" => "Images required",
		    "image_required" => "Image required",

		    "still" => "still",

		    'category' => 'Category',

		    'total_predictions' => 'A total of',
		    'correctly_predicted' => 'correctly predicted',
		    'of' => 'of',
		    'total_images' => 'images',
		    'images_recognized' => 'images were recognized.',
		    'corresponds_to' => 'This corresponds to',
		    'percentage' => 'percentage',
		    'training_for' => 'Training for',
		    'result' => 'result',
		    'color_got' => 'color obtained',
		    'total_images_in_category' => 'total images in the category',
		    'images_from_category' => 'images from category',
		    'correctly_recognized' => 'were correctly recognized',
		    'number_of_images' => 'number of images',
		    'images_of_category' => 'images of the category',
		    'recognized_as_category' => 'recognized as category',

		    'the_training_for' => "The Training for",
		    'images_of_category' => 'images of category',
		    "was_detected_as_category" => "was detected as category",
		    "resulted_in" => "resulted in",
		    "this_means" => "This means, ",
		    "were_detected_correctly" => "were detected correctly",
		    "of" => "of",
		    "were_detected_properly" => "were detected properly",
		    "erkannt" => "",
		    "images_recognized_properly" => "images recognized correctly",
		    "images_from_category" => "images from the category",

		    "the_following_problems_must_be_solved_before_training" => "The following issues need to be solved before training",
		    "there_have_to_be_at_least_two_categories" => "There have to be at least 2 categories",
		    "some_category_names_are_equal" => "Some of the category names are equal. Each category needs a unique name.",
		    "list_of_category_names_was_empty" => "The list of category names was empty",

		    "the_higher_up_the_images_the_more_sure_the_network_is" => "The higher up the images are in the category, the surer the network is in the classification."
	    ),

	    'de' => array(
		    "predicted_category" => "Vorhergesagte Kategorie",
		    "correct_category" => "Richtige Kategorie",
		    "model_was_set" => "Modell erfolgreich gesetzt",
		    "example_csv_shoe_size" => "Schuhbeispiel-CSV laden (0 = m\u00e4nnlich, 1 = weiblich)",
		    "Brandschutz" => "Brandschutz",
		    "Gebot" => "Gebot",
		    "we_want_to_train_this_model_5_categories" => "Der Computer soll nun lernen, Bilder in die jeweils passende der f\u00fcnf vorgegebenen Kategorien einzuordnen.",
		    "fire" => "Brandschutz",
		    "mandatory" => "Gebot",
		    "prohibition" => "Verbot",
		    "rescue" => "Rettung",
		    "warning" => "Warnung",
		    "the_more_variations_the_model_sees" => "Je mehr Variationen das Modell sieht, desto besser kann es die wichtigsten Merkmale der Bilder lernen.",
		    "quality_depends_on_random" => "Die Qualit\u00e4t des Ergebnisses h\u00e4ngt vom Zufall ab.",
		    "program_looks_at_data" => "Der Lernprozess (das Training) l\u00e4uft jetzt und der Computer probiert durch Versuch und Irrtum sehr viele verschiedene Filterkonfigurationen aus.",
		    "the_further_on_top_the_better" => "Insbesondere am Anfang des Trainings werden viele Bilder noch in die falsche Kategorie eingeordnet. Im weiteren Verlauf wird dann zunehmend jeweils die richtige Kategorie zugeordnet, wobei diese Zuordnung auch immer zuverl\u00e4ssiger ist. Diese kategoriale Zuordnung ist umso zuverl\u00e4ssiger, je weiter ein Bild nach oben in den blauen Bereich wandert.",
		    "add_category" => "Kategorie hinzuf\u00fcgen",
		    "settings" => "Einstellungen",
		    "description" => "Be&shy;schrei&shy;bung",
		    "use_bias" => "Bias benutzen",
		    "activation_function" => "Aktivier&shy;ungs&shy;fun&shy;ktion",
		    "bias_initializer" => "Bias-Initialisierer",
		    "kernel_initializer" => "Kernel-Initialisierer",
		    "trainable" => "Trainierbar",
		    "visualize_layer" => "Layer visualisieren",
		    "visualize_this_layer" => "Diesen Layer visualisieren",
		    "examples" => "Beispiele",
		    "dataset" => "Datensatz",
		    "height" => "H\u00f6he",
		    "width" => "Breite",
		    "batch_size" => "Batchgr\u00f6\u00dfe",
		    "epochs" => "Epochen",
		    "own_data" => "Datenquelle",
		    "filters" => "Filter",
		    "distribution" => "Verteilung",
		    "image_options" => "Bildoptionen",
		    "feature_extraction" => "Merkmalsex&shy;traktion",
		    "classification" => "Klassi&shy;fikation",
		    "flatten" => "Verflachen",
		    "dataset_and_network" => "Datensatz und Netzwerk",
		    "visualization" => "Modellvisualisierung",
		    "data" => "Daten",
		    "training_data" => "Daten",
		    "currently_the_network_has_seen" => "Die verbleibende Zeit in dieser Trainingsphase betr\u00e4gt noch ca.",
		    "of" => "von",
		    "times_seen" => "mal angesehen",
		    "it_will_take_about" => "Es wird noch ca.",
		    "remain_left" => "dauern",
		    "camera_draw_self" => "Kamera\/selbstmalen",
		    "click_on" => "Ber\u00fchre",
		    "if_bad_continue_training" => "Wenn die Ergebnisse noch zu schlecht sind, trainiere weiter.",
		    "the_ai_thinks_categories_look_like_this" => "Eine visuelle Repr\u00e4sentation dessen, was die KI gelernt hat",
		    "it_might_only_be_noise" => "Daher sehen Sie hier wahrscheinlich nur Rauschen und die Erkennung geht noch nicht.",
		    "image_left" => "Bild \u00fcbrig",
		    "images_left" => "Bilder \u00fcbrig",
		    "beginner" => "Anf\u00e4nger",
		    "expert" => "Experte",
		    "except_last_layer" => "au\u00dfer letztem Layer",
		    "activation_functions" => "Aktivierungsfunktionen",
		    "set_for_all_layers" => "Einstellungen f\u00fcr alle Layer",
		    "shuffle_before_each_epoch" => "Vor jeder Epoche zuf\u00e4llig sortieren",
		    "summary" => "Zusammenfassung",
		    "own_images" => "Eigene Bilder",
		    "own_tensor" => "Eigene Tensoren",
		    "kernel_size" => "Kernel-Gr\u00f6\u00dfe",
		    "start_training" => "Training starten",
		    "stop_training" => "Training stoppen",
		    "imprint" => "Impressum",
		    "change_shape" => "Shape ver\u00e4ndern",
		    "simulate_real_data" => "Echten Daten simulieren",
		    "dimensionality_reduction" => "Di&shy;men&shy;sio&shy;ns&shy;re&shy;duk&shy;tion",
		    "shy_activation_function" => "Ak&shy;ti&shy;vier&shy;ungsfun&shy;ktion",
		    "shy_overfitting_prevention" => "Over&shy;fit&shy;ting ver&shy;hinderung",
		    "rescale_and_recenter" => "Reskalierung und Zentrierung",
		    "show_layer_data_flow" => "Datenfluss anzeigen",
		    "show_grad_cam" => "gradCAM anzeigen",
		    "code" => "Quellcode",
		    "own_csv" => "Eigene CSV",
		    "training" => "Training",
		    "predict" => "Predict",
		    "hyperparameters" => "Hyperparameter",
		    "valsplit" => "Val.-Split",
		    "divide_x_by" => "Teile <i>X<\/i> durch",
		    "metric" => "Metrik",
		    "loss" => "Loss",
		    "optimizer" => "Optimierer",
		    "learning_rate" => "Lernrate",
		    "enable_tf_debug" => "TFJS Debugger aktivieren",
		    "enable_webcam" => "Webcam aktivieren",
		    "disable_webcam" => "Webcam deaktivieren",
		    "switch_to_other_cam" => "Zur anderen Kamera wechseln",
		    "copy_to_clipboard" => "In Zwischenablage kopieren",
		    "copy_to_clipboard_debug" => "In Zwischenablage kopieren (Debug)",
		    "set_all_initializers" => "Setze alle Initialisierer",
		    "augmentation" => "Augmentierung",
		    "iterations" => "Iterationen",
		    "close" => "Schlie\u00dfen",
		    "register" => "Registrieren",
		    "csv" => "CSV",
		    "math" => "Mathe",
		    "smaller" => "Kleiner",
		    "larger" => "Gr\u00f6\u00dfer",
		    "reset" => "Reset",
		    "delete_predictions" => "Predictions l\u00f6schen",
		    "memory_usage_while_training" => "Speicherverbrauch w\u00e4hrend des Trainings (pro Batch)",
		    "img_per_cat" => "Bilder\/Kat.",
		    "batches" => "Batches",
		    "login" => "Anmelden",
		    "username" => "Benutzername",
		    "password" => "Passwort",
		    "download" => "Herunterladen",
		    "email" => "E-Mail",
		    "public" => "\u00d6ffentlich",
		    "save" => "Speichern",
		    "augment" => "Augmentieren",
		    "download_model_data" => "Modelldaten downloaden",
		    "logout" => "Abmelden",
		    "load" => "laden",
		    "download_for_local_taurus" => "F\u00fcr lokales oder Taurus-Training herunterladen",
		    "max_activated_neurons" => "Maximal aktivierte Neuronen",
		    "no_default_data" => "Standarddaten",
		    "yes_own_tensor" => "&#x2318; eigene Tensordaten",
		    "yes_own_csv" => "&#128290; eigene CSV",
		    "yes_own_images" => "&#128444; eigene Bilder\/Webcam",
		    "width_amp_height" => "H\u00f6he&amp;Breite (0 = auto)",
		    "randomizer_limits" => "Randomisierergrenzen",
		    "max_neurons_fcnn" => "Max. Neuronen FCNN",
		    "various_plots" => "Verschiedene Plots",
		    "sources_and_used_programs" => "Quellen",
		    "visualize_images_in_grid" => "Bilder in Grid visualisieren",
		    "model_compiled_successfully" => "Modell erfolgreich kompiliert",
		    "not_creating_model_because_values_are_missing" => "Kann Modell nicht erstellen, weil Werte fehlen",
		    "tensors" => "Tensoren",
		    "set_val_split_to" => "Setze den Validation-Split auf ",
		    "set_optimizer_to" => "Setze den Optimierer auf ",
		    "set_metric_to" => "Setze die Metrik auf ",
		    "set_loss_to" => "Setze den Loss auf ",
		    "show_bars_instead_of_numbers" => "Balken statt Zahlen verwenden",
		    "number_of_grid_images" => "Anzahl Bilder im Grid",
		    "show_raw_data" => "Rohdaten anzeigen",
		    "pixel_size" => "Pixelgr\u00f6\u00dfe",
		    "auto_rotate_images" => "Bilder automatisch rotieren",
		    "number_of_rotations" => "Anzahl Rotationen",
		    "pretext_prepare_data" => "Sie m\u00fcssen Ihre Daten selbst vorbereiten! Sie k\u00f6nnen folgenden Code nehmen, um Datenstrukturen aus Python in das richtige Format umzuwandeln, das Sie mit asanAI benutzen k\u00f6nnen.",
		    "reset_view" => "Ansicht zur\u00fccksetzen",
		    "reinitialize_weights" => "Gewichte reinitialisieren",
		    "show_input_layer" => "Input-Layer anzeigen",
		    "batch_plot_minimum_time" => "Minimale Zeit zwischen Batch-Plots",
		    "loss_metric_data_and_shape" => "Loss, Metrik, Daten und Shapes",
		    "sine_ripple" => "Sinus-Kr\u00e4usel",
		    "invert_images" => "Bilder invertieren",
		    "flip_left_right" => "Bilder spiegeln",
		    "layer_data_flow" => "Layer-Datenfluss",
		    "dense_description" => "Erstellt eine dichte (vollst\u00e4ndig verbundene) Schicht.<br>Diese Schicht implementiert die Operation => <span class=\"temml_me\">\\mathrm{output} = \\mathrm{activation}\\left(\\mathrm{input} \\cdot \\mathrm{kernel} + \\text{bias}\\right)<\/span>. Die Aktivierung ist die elementweise Aktivierungsfunktion, die als Aktivierungsargument \u00fcbergeben wird.<br><tt>kernel<\/tt> ist eine Gewichtsmatrix, die von der Schicht erstellt wird.<br><tt>bis<\/tt> ist ein Bias-Vektor, der von der Schicht erstellt wird (nur anwendbar, wenn useBias true ist).",
		    "flatten_description" => "Flacht die Eingabe ab. Beeinflusst nicht die Batch-Gr\u00f6\u00dfe. Eine Flatten-Schicht macht in ihren Eingaben jede Batch in 1D flach (wodurch die Ausgabe 2D wird).",
		    "dropout_description" => "Dropout besteht darin, eine Bruchteilrate der Eingabeeinheiten w\u00e4hrend jeder Aktualisierung w\u00e4hrend der Trainingszeit zuf\u00e4llig auf 0 zu setzen, was \u00dcberanpassung verhindert.",
		    "reshape_description" => "Formt eine Eingabe in eine bestimmte Form um.",
		    "elu_description" => "Exponential Linear Unit (ELU).<br>Gleichung => <span class='temml_me'>\\text{elu}\\left(x\\right) = \\left\\{\\begin{array}{ll} \\alpha \\cdot \\left(e^x - 1\\right) & \\text{for } x < 0 \\\\ \n x & \\text{for } x >= 0\\end{array}\\right.<\/span>",
		    "leakyReLU_description" => "Leaky-Version einer rektifizierten linearen Einheit.<br>Sie erlaubt eine kleine Steigung, wenn die Einheit nicht aktiv ist => <span class='temml_me'>\\text{leakyReLU}(x) = \\left\\{\\begin{array}{ll} \\alpha \\cdot x & \\text{for } x < 0 \\\\ \n x & \\text{for } x >= 0 \\end{array}\\right.<\/span>",
		    "reLU_description" => "Aktivierungsfunktion der rektifizierten linearen Einheit. <span class=\"temml_me\">\\mathrm{relu}\\left(x\\right) = \\mathrm{max}\\left(\\mathrm{Max-Value}, x\\right)<\/span>",
		    "softmax_description" => "Softmax-Aktivierungsschicht. <span class=\"temml_me\">\\mathrm{softmax}\\left(x\\right) = \\frac{e^{z_j}}{\\sum^K_{k=1} e^{z_k}}<\/span>",
		    "thresholdedReLU_description" => "Thresholded Rectified Linear Unit. Gleichung => <span class='temml_me'>f(x) = \\left\\{\\begin{array}{ll} x & \\text{for } x > \\theta \\\\ \n 0 & \\text{otherwise}\\end{array}\\right.<\/span>",
		    "batchNormalization_description" => "Batch-Normalisierungsschicht (<a href='https =>\/\/arxiv.org\/abs\/1502.03167' target='_blank'>Ioffe and Szegedy, 2014<\/a>).<br>Normalisieren Sie die Aktivierungen der vorherigen Schicht in jeder Batch, d.h. wendet eine Transformation an, die die mittlere Aktivierung nahe bei 0 und die Aktivierungsstandardabweichung nahe bei 1 h\u00e4lt.",
		    "layerNormalization_description" => "Schicht-Normalisierungsschicht (<a target='_blank' href='https =>\/\/arxiv.org\/abs\/1607.06450'>Ba et al., 2016<\/a>). Normalisieren Sie die Aktivierungen der vorherigen Schicht f\u00fcr jedes gegebene Beispiel in einer Batch unabh\u00e4ngig voneinander, anstatt in einer Batch wie in der Batch-Normalisierung. Mit anderen Worten, diese Schicht wendet eine Transformation an, die die mittlere Aktivierung innerhalb jedes Beispiels nahe bei 0 und die Aktivierungsvarianz nahe bei 1 h\u00e4lt.",
		    "conv1d_description" => "1D-Faltungs-Schicht (z.B. zeitliche Faltung).<br>Diese Schicht erstellt einen Faltungskern, der mit der Eingabe der Schicht \u00fcber eine einzelne r\u00e4umliche (oder zeitliche) Dimension gefaltet wird, um einen Tensor von Ausgaben zu erzeugen.<br>Wenn <tt>use_bias<\/tt> True ist, wird ein Bias-Vektor erstellt und den Ausgaben hinzugef\u00fcgt.<br>Wenn <tt>activation<\/tt> nicht <tt>null<\/tt> ist, wird es auch auf die Ausgaben angewendet.",
		    "conv2d_description" => "2D-Faltungs-Schicht (z.B. r\u00e4umliche Faltung \u00fcber Bilder).<br>Diese Schicht erstellt einen Faltungskern, der mit der Eingabe der Schicht gefaltet wird, um einen Tensor von Ausgaben zu erzeugen.<br>Wenn <tt>useBias<\/tt> True ist, wird ein Bias-Vektor erstellt und den Ausgaben hinzugef\u00fcgt.<br>Wenn <tt>activation<\/tt> nicht null ist, wird es auch auf die Ausgaben angewendet.",
		    "conv2dTranspose_description" => "Transponierte Faltungsschicht (manchmal auch Deconvolution genannt). Der Bedarf an transponierten Faltungen ergibt sich in der Regel aus dem Wunsch, eine Transformation in die entgegengesetzte Richtung einer normalen Faltung zu verwenden, d.h. von etwas, das die Form der Ausgabe einiger Faltungen hat, zu etwas, das die Form ihres Eingangs hat, w\u00e4hrend ein Konnektivit\u00e4tsmuster beibehalten wird, das mit dieser Faltung kompatibel ist.",
		    "conv3d_description" => "3D-Faltungs-Schicht (z.B. r\u00e4umliche Faltung \u00fcber Volumen).<br>Diese Schicht erstellt einen Faltungskern, der mit der Eingabe der Schicht gefaltet wird, um einen Tensor von Ausgaben zu erzeugen.",
		    "depthwiseConv2d_description" => "Tiefe separierbare 2D-Faltung. Tiefe separierbare Faltungen bestehen darin, nur den ersten Schritt einer tiefen r\u00e4umlichen Faltung durchzuf\u00fchren (die auf jede Eingabeschicht separat wirkt). Das Argument \"depthMultiplier\" steuert, wie viele Ausgabeschichten pro Eingabeschicht im Tiefe-Schritt generiert werden.",
		    "separableConv2d_description" => "Tiefe separierbare 2D-Faltung. Separierbare Faltung besteht darin, zuerst eine r\u00e4umliche Faltung in der Tiefe (die auf jede Eingabeschicht separat wirkt) durchzuf\u00fchren, gefolgt von einer punktweisen Faltung, die die resultierenden Ausgabeschichten miteinander vermischt. Das Argument \"depthMultiplier\" steuert, wie viele Ausgabeschichten pro Eingabeschicht im Tiefe-Stufen-Schritt generiert werden.",
		    "upSampling2d_description" => "Upsampling-Schicht f\u00fcr 2D-Eingaben. Wiederholt die Zeilen und Spalten der Daten jeweils um <tt>size[0]<\/tt> bzw. <tt>size[1]<\/tt> Mal.",
		    "averagePooling1d_description" => "Durchschnittliche Pooling-Operation f\u00fcr r\u00e4umliche Daten.",
		    "averagePooling2d_description" => "Durchschnittliche Pooling-Operation f\u00fcr r\u00e4umliche Daten.",
		    "averagePooling3d_description" => "Durchschnittliche Pooling-Operation f\u00fcr 3d Daten.",
		    "maxPooling1d_description" => "Maximale Pooling-Operation f\u00fcr zeitliche Daten.",
		    "maxPooling2d_description" => "Globale Max-Pooling-Operation f\u00fcr r\u00e4umliche Daten.",
		    "maxPooling3d_description" => "Globale Max-Pooling-Operation f\u00fcr 3d Daten.",
		    "alphaDropout_description" => "Wendet Alpha-Dropout auf die Eingabe an. Da es sich um eine Regularisierungsschicht handelt, ist sie nur w\u00e4hrend des Trainings aktiv.",
		    "gaussianDropout_description" => "Wendet multiplikatives gau\u00dfsches Rauschen mit einer Zentrierung um 1 an. Da es sich um eine Regularisierungsschicht handelt, ist sie nur w\u00e4hrend des Trainings aktiv.",
		    "gaussianNoise_description" => "F\u00fcge additive gau\u00dfsches Rauschen mit einer Null-Zentrierung hinzu. Da es sich um eine Regularisierungsschicht handelt, ist sie nur w\u00e4hrend des Trainings aktiv.",
		    "DebugLayer_description" => "Protokolliert den internen Zustand der Daten in die Entwicklerkonsole (wie <tt>console.log<\/tt>). Tut nichts mit den Daten selbst und gibt sie unver\u00e4ndert zur\u00fcck.",
		    "max_number_of_values" => "Maximale Anzahl an Werten (0 = kein Limit)",
		    "provide_x_data" => "X-Daten",
		    "provide_y_data" => "Y-Daten",
		    "download_custom_zip_file" => "Downloade die eigenen Daten als .zip-Datei",
		    "delay_between_images" => "Wartezeit zwischen den Bildern in der Serie",
		    "number_of_images_in_series" => "Anzahl Bilder pro Serie",
		    "restart_fcnn" => "FCNN neustarten",
		    "restart_lenet" => "LeNet neustarten",
		    "undo_redo_stack_lost" => "R\u00fcckg\u00e4ngig\/wiederherstellen-Stack verloren!",
		    "changing_mode_deletes_stack" => "Das \u00e4ndern des Modus l\u00f6scht den gesamten Undo\/Redo-Stack.",
		    "auto_adjust_last_layer_if_dense" => "Automatisch den letzten Layer anpassen (wenn Dense)",
		    "load_images" => "Lade Bilder",
		    "loading_data" => "Lade Daten",
		    "ai_tries_to_draw" => "Die KI versucht zu malen, wie sie diese Kategorien gelernt hat...",
		    "stop_generating_images" => "Bildgenerierung stoppen",
		    "stopped_generating_images" => "Die Bildgenerierung wurde gestoppt. Das kann einen Moment dauern.",
		    "now_being" => "Jetzt werden",
		    "images_of_each_category" => "Bilder aus jeder Kategorie geladen.",
		    "one_second" => "1 Sekunde",
		    "years" => "Jahre",
		    "year" => "Jahr",
		    "minutes" => "Minuten",
		    "minute" => "Minute",
		    "seconds" => "Sekunden",
		    "hours" => "Stunden",
		    "second" => "Sekunde",
		    "days" => "Tage",
		    "day" => "Tag",
		    "left" => "\u00fcbrig",
		    "example_images" => "Beispielbilder",
		    "and_try_to_draw_a_warning_sign" => "und versuche ein Warnschild zu malen",
		    "go_back_to_examples" => "um zu den Beispielbildern zur\u00fcckzugehen",
		    "the_training_was_only_with" => "Das Training wurde mit insgesamt nur",
		    "images_and" => "Bildern und",
		    "epochs_done" => "Epochen gemacht. Die Ergebnisse sind also wahrscheinlich schlecht",
		    "this_may_take_a_while" => "Das kann einen Moment dauern",
		    "loading_images_into_memory" => "Lade die Bilder in den Speicher",
		    "train_the_neural_network" => "Hier klicken, um neuronales Netz zu trainieren",
		    "train_further" => "Das Netzwerk weiter trainieren",
		    "loading_model" => "Lade Modell",
		    "loading_example_images" => "Lade Beispielbilder",
		    "undoing_redoing" => "R\u00fcckg\u00e4ngig machen\/wiederherstellen",
		    "skip_presentation" => "\u00dcberspringen &rarr;",
		    "very_unsure" => "Sehr unsicher",
		    "quite_unsure" => "Eher unsicher",
		    "a_bit_unsure" => "Ein wenig unsicher",
		    "neutral" => "Ein wenig sicher",
		    "relatively_sure" => "Relativ sicher",
		    "very_sure" => "Sehr sicher",
		    "time_per_batch" => "Zeit pro Batch",
		    "done_training_took" => "Training fertig, es dauerte",
		    "done_generating_images" => "Bilder fertig generiert",
		    "generating_image_for_neuron" => "Generiere Bild f\u00fcr Neuron",
		    "failed_try_again" => "fehlgeschlagen. Versuche es erneut",
		    "fixing_output_shape" => "Output-Shape wird repariert",
		    "output_shape_repaired" => "Output shape repariert",
		    "please_try_training_again" => "Bitte erneut trainieren",
		    "No" => "Nein",
		    "Yes" => "Ja",
		    "autofix_output_shape" => "M\u00f6chten Sie die Output-Shape automatisch reparieren lassen?",
		    "defective_output_shape" => "Kaputte Output-Shape entdeckt!",
		    "switched_to_beginner_mode" => "In den Anf\u00e4ngermodus gewechselt",
		    "changed_mode_from" => "Modus von",
		    "to" => "nach",
		    "lost_undo_redo_stack" => "R\u00fcckg\u00e4ngig\/wiederherstellen resettet",
		    "stopped_training" => "Training beendet",
		    "allow_math_mode_for_all_layers" => "Mathe-Modus f\u00fcr alle Layer erlauben",
		    "updating_predictions" => "Aktualisiere Predictions",
		    "loaded_configuration" => "Konfiguration geladen",
		    "model_is_not_defined" => "Modell ist nicht definiert",
		    "model_is_ok" => "Modell ist OK",
		    "got_data" => "Daten geholt, Tensoren erstellt",
		    "site_is_ready" => "Seite fertig geladen",
		    "trying_to_set_backend" => "Versuche, das Backend zu setzen",
		    "backend_set" => "Backend gesetzt",
		    "set_theme" => "Setze Theme",
		    "theme_set" => "Theme gesetzt",
		    "has_cookie_for" => "Hat Cookie f\u00fcr",
		    "initializing_losses" => "Initialisiere Losses",
		    "initializing_metrics" => "Initialisiere Metriken",
		    "setting_backend" => "Setze Backend",
		    "changing" => "\u00c4ndere",
		    "changed_data_source" => "Datenquelle ge\u00e4ndert",
		    "hiding_augmentation" => "Augmentierung versteckt",
		    "showing_augmentation" => "Augmentierung gezeigt",
		    "input_shape_is_read_only" => "Die Input-Shape ist nur lesbar",
		    "input_shape_is_writable" => "Die Input-Shape ist bearbeitbar",
		    "updating_page" => "Update die Seite...",
		    "page_update_took" => "Das Seitenupdate brauchte",
		    "getting_labels" => "Hole Labels",
		    "compiling_model" => "Kompiliere Modell",
		    "done_changing" => "Fertig mit \u00c4ndern der",
		    "took" => "brauchte",
		    "setting_layer" => "Setze Layer",
		    "setting_options_for_layer" => "Setze Optionen f\u00fcr Layer",
		    "creating_model" => "Erstelle Modell",
		    "graph_explanation" => "Die Linien im Graphen zeigen den Fehler an. Umso niedriger die Linie, desto geringer der Fehler.<hr class='cosmo_hr'>Die blaue Linie zeigt die Verbesserungen auf den Daten, auf denen das Netzwerk trainiert.<hr class='cosmo_hr'>Die orange Linie zeigt an, wie gut es es auf Daten ist, die es nicht gesehen hat.<br>Beide Linien sollten niedriger werden und etwa \u00e4hnlich aussehen, damit das Training gut l\u00e4uft.",
		    "previous_images" => "Vorherige Bilder",
		    "current_images" => "Aktuelle Bilder",
		    "predictions_explanation_while_training" => "Unten ist je ein Beispiel aus jeder Kategorie. Die Balken zeigen, wie viel Prozent die jeweilige Kategorie erkannt wurde. Die am meisten erkannte Kategorie ist gr\u00fcn. Sie k\u00f6nnen live sehen, wie sich die Kategorien ver\u00e4ndern, w\u00e4hrend das Netzwerk lernt.",
		    "Verbot" => "Verbot",
		    "Rettung" => "Rettung",
		    "Warnung" => "Warnung",
		    "currently" => "Aktuell",
		    "correct" => "richtig",
		    "wrong" => "Falsch",
		    "total" => "Gesamt",
		    "images_are_being_detected_correctly" => "Bilder wurden richtig erkannt",
		    "category" => "Kategorie",
		    "percentage_correct" => "Prozent richtig",
		    "training_done_text" => "Diese Trainingsphase ist abgeschlossen. Sollte die Genauigkeit noch nicht ausreichend sein, kann das Netz weiter trainiert werden, um m\u00f6glicherweise bessere Ergebnisse zu erzielen.",
		    "initializing_categories" => "Kategorien werden initialisiert",
		    "initializing_tabs" => "Initialisiere Tabs",
		    "initializing_page_contents" => "Initialisiere Seiteninhalte",
		    "initializing_set_options_for_all" => "Initialisiere 'Setze Optionen f\u00fcr alle Layer'",
		    "got_data_creating_tensors" => "Daten geholt, erstelle Tensoren...",
		    "started_training" => "Training gestartet",
		    "compiling model" => "Kompiliere Modell",
		    "compiled_model" => "Modell kompiliert",
		    "finished_training" => "Training beendet",
		    "stopped_downloading_because_button_was_clicked" => "Download gestoppt, weil der Download-Stoppen-Button geklickt wurde",


		    "correct_category" => "Richtige Kategorie",
		    "model_was_set" => "Modell erfolgreich gesetzt",
		    'optimizer' => 'Optimierer',
		    'a_neural_network_is_an_algorithm_that_mimics_the_functionality_of_the_human_brain' => 'Ein Neuronales Netz ist ein Algorithmus, der die Funktionsweise des menschlichen Gehirns nachahmt.',
		    'it_can_solve_complex_tasks_in_computer_science_economics_mathematics_etc' => 'Damit lassen sich komplexe Aufgaben aus der Informatik, Wirtschaft, Mathematik etc. lösen.',
		    'a_neural_network_is_trained' => 'Ein Neuronales Netz wird trainiert.',
		    'this_model_of_machine_learning_is_also_the_basis_for_artificial_intelligences' => 'Dieses Modell des Machine Learning ist auch die Grundlage für Künstliche Intelligenzen.',

		    'like_the_human_brain_a_neural_network_also_consists_of_artificial_neurons' => 'Wie das menschliche Gehirn, besteht auch ein Neuronales Netzwerk aus (künstlichen) Neuronen.',
		    'the_neurons_are_arranged_in_different_layers_the_input_layer_receives_the_initial_data_such_as_images' => 'Die Neuronen liegen in verschiedenen Layern. Dem Input-Layer werden die initialen Daten, wie z.B. Bilder, übergeben.',
		    'afterwards_several_hidden_layers_follow_where_the_edges_between_the_nodes_are_weighted' => 'Danach folgen mehrere versteckte Layer, in denen die Kanten zwischen den Knoten gewichtet werden.',
		    'the_output_layer_provides_the_image_category_calculated_based_on_the_input_data' => 'Der Output-Layer gibt die Bild-Kategorie aus, welches aufgrund der Input-Daten berechnet wurde.',

		    'the_neurons_receive_modify_and_pass_on_information_to_the_next_neuron' => 'Die Neuronen nehmen Informationen auf, modifizieren sie und geben sie an das nächste Neuron weiter.',
		    'the_variously_weighted_edges_leading_to_a_neuron_determine_the_value_of_the_next_neuron' => 'Die verschieden gewichteten Kanten die zu einem Neuron führen, bestimmen den Wert des nächsten Neurons.',
		    'an_activation_function_decides_whether_and_with_what_value_information_is_passed_on_to_the_next_neuron' => 'Eine Aktivierungsfunktion entscheidet, ob bzw. mit welchem Wert Informationen an das nächste Neuron weitergegeben werden.',

		    'the_network_is_trained_on_a_classified_dataset' => 'Das Netzwerk wird anhand eines klassifizierten Datensatzes trainiert.',
		    'it_learns_through_feedback_whether_the_predicted_output_is_right_or_wrong' => 'Es lernt durch Feedback, ob der vermutete Output richtig oder falsch ist.',
		    'the_values_in_the_input_layer_are_randomly_chosen_at_first_and_adjusted_with_each_pass_through_the_neural_network_until_the_correct_result_is_output_in_the_output_layer' => 'Die Werte im Input-Layer sind zu Beginn zufällig gewählt und werden mit jedem Durchgang durch das Neuronale Netzwerk angepasst, bis im Output-Layer das richtige Ergebnis ausgegeben wird.',
		    'learning_rate' => 'Lernrate',
		    'try_it' => "Ausprobieren",
		    "neural_network" => "Neuronales Netz",

		    'choose_an_existing_dataset_or_create_your_own' => 'Wähle einen existierenden Datensatz oder erstelle deinen Eigenen',
		    'fruit' => 'Obst',
		    'everyday_objects' => 'Alltagsgegenstände',
		    'own_dataset' => 'Eigener Datensatz',

		    'load_test_images_and_start_training' => 'Test-Bilder laden und Training beginnen',
		    'categorized_test_images_are_loaded_for_each_fruit' => 'Für jedes Obst werden kategorisierte Test-Bilder geladen.',
		    'the_neural_network_selects_a_random_path_through_the_network_for_each_image' => 'Das Neuronale Netz wählt für jedes Bild einen zufälligen Weg durch das Netzwerk.',
		    'if_a_wrong_result_occurs_it_is_corrected' => 'Kommt es zu einem falschen Ergebnis, wird es korrigiert.',
		    'using_this_feedback_the_path_is_adjusted_until_the_network_arrives_at_the_correct_output' => 'Mithilfe dieses Feedbacks wird der Weg angepasst, bis das Netz zu einem richtigen Output gelangt.',
		    'the_more_passes_the_more_effective_the_training' => 'Je mehr Durchgänge es gibt, desto effektiver ist das Training.',
		    'in_this_example_there_are' => 'In diesem Beispiel sind es',
		    'passes' => 'Durchgänge',
		    'hold_a_fruit_in_front_of_the_camera' => 'Halte eine Frucht in die Kamera:',
		    'hold_a_key_coin_or_bill_into_the_camera' => 'Halte eine Münze, einen Schlüssel oder einen Geldschein vor die Kamera:',
		    'the_input_image_is_converted_into_a_matrix_with' => 'Das Input-Bild wird zu einer',
		    'pixels_representing_the_height_and_width_with_color_channels_red_green_and_blue' => '-Pixel-Matrix, die Höhe und Breite sowie in der 3. Dimension die Farbkanäle rot, grün und blau abbildet.',
		    "hold_one_of_the_objects_you_trained_the_network_on_in_front_of_the_camera" => "Halte eines der Objekte, auf die du das Netz trainiert hast, vor die Kamera:",
		    'in_the_layers_various_features_such_as_edges_are_filtered_from_the_image' => 'In den Layern werden verschiedene Merkmale wie z.B. Kanten aus dem Bild gefiltert.',
		    'in_each_layer_the_image_is_sampled_section_by_section_using_kernels' => 'In jeder Schicht wird das Bild abschnittsweise über Kernels abgetastet.',
		    'based_on_the_extracted_features_the_image_is_finally_classified' => 'Anhand der extrahierten Merkmale kann das Bild letztendlich klassifiziert werden.',

		    'show_evaluation' => 'Auswertung anzeigen',
		    'try_yourself' => 'Ausprobieren',
		    'the_input_image_is_converted_into_a_matrix_with' => 'Das Input-Bild wird zu einer',
		    'pixels_representing_height_and_width_and_color_channels_red_green_blue' => '-Pixel-Matrix, die Höhe und Breite sowie in der 3. Dimension die Farbkanäle rot, grün und blau abbildet.',
		    'various_features_such_as_edges_are_filtered_from_the_image_in_the_layers' => 'In den Layern werden verschiedene Merkmale wie z.B. Kanten aus dem Bild gefiltert.',
		    'in_each_layer_the_image_is_sampled_section_by_section_using_kernels' => 'In jeder Schicht wird das Bild abschnittsweise über Kernels abgetastet.',
		    'based_on_extracted_features_the_image_is_classified' => 'Anhand der extrahierten Merkmale kann das Bild letztendlich klassifiziert werden.',

		    'load_test_images_and_start_training' => 'Test-Bilder laden und Training beginnen',
		    'for_each_category_categorized_test_images_are_loaded' => 'Für jede Kategorie werden kategorisierte Test-Bilder geladen.',
		    'the_neural_network_selects_a_random_path_through_the_network_for_each_image' => 'Das Neuronale Netz wählt für jedes Bild einen zufälligen Weg durch das Netzwerk.',
		    'if_a_wrong_result_occurs_it_is_corrected' => 'Kommt es zu einem falschen Ergebnis, wird es korrigiert.',
		    'with_the_help_of_this_feedback_the_path_is_adjusted_until_the_network_reaches_a_correct_output' => 'Mithilfe dieses Feedbacks wird der Weg angepasst, bis das Netz zu einem richtigen Output gelangt.',
		    'the_more_iterations_there_are_the_more_effective_the_training' => 'Je mehr Durchgänge es gibt, desto effektiver ist das Training.',
		    'in_this_example_there_are' => 'In diesem Beispiel sind es',
		    'iterations' => 'Durchgänge.',
		    'show_evaluation' => 'Auswertung anzeigen',
		    'try_yourself' => 'Ausprobieren',
		    'hold_a_key_a_banknote_or_a_coin_in_front_of_the_camera' => 'Halte Schlüssel, Geldschein oder Münze in die Kamera:',
		    'the_input_image_is_converted_into_a_matrix_with' => 'Das Input-Bild wird zu einer',
		    'pixels_representing_height_and_width_and_color_channels_red_green_blue' => '-Pixel-Matrix, die Höhe und Breite sowie in der 3. Dimension die Farbkanäle rot, grün und blau abbildet.',
		    'various_features_such_as_edges_are_filtered_from_the_image_in_the_layers' => 'In den Layern werden verschiedene Merkmale wie z.B. Kanten aus dem Bild gefiltert.',
		    'in_each_layer_the_image_is_sampled_section_by_section_using_kernels' => 'In jeder Schicht wird das Bild abschnittsweise über Kernels abgetastet.',
		    'based_on_extracted_features_the_image_is_classified' => 'Anhand der extrahierten Merkmale kann das Bild letztendlich klassifiziert werden.',

		    'for_images_of_each_category_test_images_are_loaded' => 'Für Bilder jeder Kategorie werden die Test-Bilder geladen.',
		    'the_neural_network_selects_a_random_path_through_the_network_for_each_image' => 'Das Neuronale Netz wählt für jedes Bild einen zufälligen Weg durch das Netzwerk.',
		    'if_a_wrong_result_occurs_it_is_corrected' => 'Kommt es zu einem falschen Ergebnis, wird es korrigiert.',
		    'with_the_help_of_this_feedback_the_path_is_adjusted_until_the_network_reaches_a_correct_output' => 'Mithilfe dieses Feedbacks wird der Weg angepasst, bis das Netz zu einem richtigen Output gelangt.',
		    'the_more_iterations_there_are_the_more_effective_the_training' => 'Je mehr Durchgänge es gibt, desto effektiver ist das Training.',
		    'in_this_example_there_are' => 'In diesem Beispiel sind es',
		    'iterations' => 'Durchgänge.',

		    'hold_one_of_the_trained_objects' => 'Halte eines der Objekte, auf die trainiert wurde, in die Kamera:',
		    'the_input_image_is_converted_into_a' => 'Das Input-Bild wird zu einer',
		    'pixel_matrix_representing_height_width_and_rgb_channels' => '-Pixel-Matrix, die Höhe und Breite sowie in der 3. Dimension die Farbkanäle rot, grün und blau abbildet.',
		    'in_the_layers_various_features_such_as_edges_are_filtered_from_the_image' => 'In den Layern werden verschiedene Merkmale wie z.B. Kanten aus dem Bild gefiltert.',
		    'in_each_layer_the_image_is_scanned_by_kernels_section_by_section' => 'In jeder Schicht wird das Bild abschnittsweise über Kernels abgetastet.',
		    'based_on_the_extracted_features_the_image_is_eventually_classified' => 'Anhand der extrahierten Merkmale kann das Bild letztendlich klassifiziert werden.',

		    'show_results' => 'Auswertung anzeigen',
		    'try_it_yourself' => 'Ausprobieren',

		    'add_category' => 'Kategorie hinzufügen',
		    'start_training' => 'Training starten',

		    "images_required" => "Bilder nötig",
		    "image_required" => "Bild nötig",

		    "still" => "noch",

		    'category' => 'Kategorie',

		    'total_predictions' => 'Es wurden insgesamt',
		    'correctly_predicted' => 'von Bildern richtig erkannt',
		    'of' => 'von',
		    'total_images' => 'Bilder',
		    'images_recognized' => 'Bilder richtig erkannt.',
		    'corresponds_to' => 'Das entspricht',
		    'percentage' => 'Prozent',
		    'training_for' => 'Das Training für',
		    'result' => 'hat ergeben',
		    'color_got' => 'erhaltene Farbe',
		    'total_images_in_category' => 'von Bildern aus der Kategorie',
		    'images_from_category' => 'Bilder aus der Kategorie',
		    'correctly_recognized' => 'wurden richtig erkannt',
		    'number_of_images' => 'Anzahl der Bilder',
		    'images_of_category' => 'Bilder der Kategorie',
		    'recognized_as_category' => 'wurden als Kategorie',

		    'the_training_for' => "Das Training für",
		    'images_of_category' => 'Bilder der Kategorie',
		    "was_detected_as_category" => "wurden erkannt als Kategorie",
		    "resulted_in" => "hat ergeben",
		    "this_means" => "Das bedeutet, ",
		    "were_detected_correctly" => "wurden richtig erkannt",
		    "of" => "von",
		    "were_detected_properly" => "wurden richtig erkannt",
		    "erkannt" => "erkannt",
		    "images_recognized_properly" => "Bildern richtig erkannt",
		    "images_from_category" => "Bildern aus der Kategorie",

		    "the_following_problems_must_be_solved_before_training" => "Folgende Probleme bestehen noch und müssen gelöst werden, bevor du trainieren kannst",
		    "there_have_to_be_at_least_two_categories" => "Es muss mindestens 2 Kategorien sein",
		    "some_category_names_are_equal" => "Einige der Kategorien haben die gleichen Namen. Jede Kategorie braucht einen eigenen Namen.",
		    "list_of_category_names_was_empty" => "Die Liste der Kategorienamen ist leer",

		    "the_higher_up_the_images_the_more_sure_the_network_is" => "Umso weiter oben die Bilder sind, desto sicherer ist sich das Netzwerk, dass sie in der entsprechenen Kategorie sind."
	    )
    );


    function checkSubElementsKeys($array)
    {
        $keys = [];

        foreach ($array as $subArray) {
            if (!is_array($subArray)) {
                die("Sub-element is not an array");
            }

            $subKeys = array_keys($subArray);

            if (empty($keys)) {
                $keys = $subKeys;
            } elseif ($keys !== $subKeys) {
                $missingKeys = array_diff($keys, $subKeys);
                if($missingKeys) {
                    die("Missing key: " . reset($missingKeys));
                }
            }
        }

        return true;
    }

    if(!checkSubElementsKeys($GLOBALS["translations"])) {
        die("Sub-elements do not have the same keys");
    }

    if(!count($GLOBALS["translations"]["en"])) {
        die("No elements in translations specified.");
    }

    print json_encode($translations);
    ?>
